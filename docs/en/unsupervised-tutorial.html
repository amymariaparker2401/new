<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Word representations · fastText</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A popular idea in modern machine learning is to represent words by vectors. These vectors capture hidden information about a language, like word analogies or semantic. It is also used to improve performance of text classifiers."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Word representations · fastText"/><meta property="og:type" content="website"/><meta property="og:url" content="https://fasttext.cc/index.html"/><meta property="og:description" content="A popular idea in modern machine learning is to represent words by vectors. These vectors capture hidden information about a language, like word analogies or semantic. It is also used to improve performance of text classifiers."/><meta property="og:image" content="https://fasttext.cc/img/ogimage.png"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/fasttext-icon-bg-web.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://fasttext.cc/blog/atom.xml" title="fastText Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://fasttext.cc/blog/feed.xml" title="fastText Blog RSS Feed"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-44373548-30', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="/tabber.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/fasttext-icon-white-web.png" alt="fastText"/></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/en/support.html" target="_self">Docs</a></li><li class=""><a href="/docs/en/english-vectors.html" target="_self">Resources</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class=""><a href="https://github.com/facebookresearch/fastText/" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Tutorials</span></h2></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/support.html">Get started</a></li><li class="navListItem"><a class="navItem" href="/docs/en/cheatsheet.html">Cheatsheet</a></li><li class="navListItem"><a class="navItem" href="/docs/en/options.html">List of options</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Tutorials</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/supervised-tutorial.html">Text classification</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/en/unsupervised-tutorial.html">Word representations</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Help</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/en/autotune.html">Automatic hyperparameter optimization</a></li><li class="navListItem"><a class="navItem" href="/docs/en/python-module.html">Python module</a></li><li class="navListItem"><a class="navItem" href="/docs/en/webassembly-module.html">WebAssembly module</a></li><li class="navListItem"><a class="navItem" href="/docs/en/faqs.html">FAQ</a></li><li class="navListItem"><a class="navItem" href="/docs/en/api.html">API</a></li><li class="navListItem"><a class="navItem" href="/docs/en/references.html">References</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Word representations</h1></header><article><div><span><p>A popular idea in modern machine learning is to represent words by vectors. These vectors capture hidden information about a language, like word analogies or semantic. It is also used to improve performance of text classifiers.</p>
<p>In this tutorial, we show how to build these word vectors with the fastText tool. To download and install fastText, follow the first steps of <a href="https://fasttext.cc/docs/en/supervised-tutorial.html">the tutorial on text classification</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="getting-the-data"></a><a href="#getting-the-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Getting the data</h2>
<p>In order to compute word vectors, you need a large text corpus. Depending on the corpus, the word vectors will capture different information. In this tutorial, we focus on Wikipedia's articles but other sources could be considered, like  news or Webcrawl (more examples <a href="http://statmt.org/">here</a>). To download a raw dump of Wikipedia, run the following command:</p>
<pre><code class="hljs css language-bash">wget https://dumps.wikimedia.org/enwiki/latest/enwiki-latest-pages-articles.xml.bz2
</code></pre>
<p>Downloading  the Wikipedia corpus takes some time. Instead, lets restrict our study to the  first 1 billion bytes of English Wikipedia. They can be found on Matt Mahoney's <a href="http://mattmahoney.net/">website</a>:</p>
<pre><code class="hljs css language-bash">$ mkdir data
$ wget -c http://mattmahoney.net/dc/enwik9.zip -P data
$ unzip data/enwik9.zip -d data
</code></pre>
<p>A raw Wikipedia dump contains a lot of HTML / XML data. We pre-process it with the wikifil.pl script bundled with fastText (this script was originally developed by Matt Mahoney, and can be found on his <a href="http://mattmahoney.net/">website</a>).</p>
<pre><code class="hljs css language-bash">$ perl wikifil.pl data/enwik9 &gt; data/fil9
</code></pre>
<p>We can check the file by running the following command:</p>
<pre><code class="hljs css language-bash">$ head -c 80 data/fil9
anarchism originated as a term of abuse first used against early working class
</code></pre>
<p>The text is nicely pre-processed and can be used to learn our word vectors.</p>
<h2><a class="anchor" aria-hidden="true" id="training-word-vectors"></a><a href="#training-word-vectors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Training word vectors</h2>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-70-tab-71" class="nav-link active" data-group="group_70" data-tab="tab-group-70-content-71">Command line</div><div id="tab-group-70-tab-72" class="nav-link" data-group="group_70" data-tab="tab-group-70-content-72">Python</div></div><div class="tab-content"><div id="tab-group-70-content-71" class="tab-pane active" data-group="group_70" tabindex="-1"><div><span><p>Learning  word vectors on this data can now be achieved with a single command:</p>
<pre><code class="hljs css language-bash">$ mkdir result<br />$ ./fasttext skipgram -input data/fil9 -output result/fil9<br /></code></pre>
<p>To decompose this command line: ./fastext calls the binary fastText executable (see how to install fastText <a href="https://fasttext.cc/docs/en/support.html">here</a>) with the 'skipgram' model  (it can also be 'cbow'). We then specify the requires options '-input' for the location of the data and '-output' for the location where the word representations will be saved.</p>
<p>While fastText is running,  the progress and estimated time to completion is shown on your screen.  Once the program finishes, there should be two files in the result directory:</p>
<pre><code class="hljs css language-bash">$ ls -l result<br />-rw-r-r-- 1 bojanowski 1876110778 978480850 Dec 20 11:01 fil9.bin<br />-rw-r-r-- 1 bojanowski 1876110778 190004182 Dec 20 11:01 fil9.vec<br /></code></pre>
<p>The <code>fil9.bin</code> file is a binary file that stores the whole fastText model and can be subsequently loaded. The <code>fil9.vec</code> file is a text file that contains the word vectors, one per line for each word in the vocabulary:</p>
<pre><code class="hljs css language-bash">$ head -n 4 result/fil9.vec<br />218316 100<br />the -0.10363 -0.063669 0.032436 -0.040798 0.53749 0.00097867 0.10083 0.24829 ...<br />of -0.0083724 0.0059414 -0.046618 -0.072735 0.83007 0.038895 -0.13634 0.60063 ...<br />one 0.32731 0.044409 -0.46484 0.14716 0.7431 0.24684 -0.11301 0.51721 0.73262 ...<br /></code></pre>
<p>The first line is a header containing the number of words and the dimensionality of the vectors. The subsequent lines are the word vectors for all words in the vocabulary, sorted by decreasing frequency.</p>
</span></div></div><div id="tab-group-70-content-72" class="tab-pane" data-group="group_70" tabindex="-1"><div><span><p>Learning  word vectors on this data can now be achieved with a single command:</p>
<pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fasttext<br /><span class="hljs-meta">&gt;&gt;&gt; </span>model = fasttext.train_unsupervised(<span class="hljs-string">'data/fil9'</span>)<br /></code></pre>
<p>While fastText is running,  the progress and estimated time to completion is shown on your screen. Once the training finishes, <code>model</code> variable contains information on the trained model, and can be used for querying:</p>
<pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.words<br />[<span class="hljs-string">u'the'</span>, <span class="hljs-string">u'of'</span>, <span class="hljs-string">u'one'</span>, <span class="hljs-string">u'zero'</span>, <span class="hljs-string">u'and'</span>, <span class="hljs-string">u'in'</span>, <span class="hljs-string">u'two'</span>, <span class="hljs-string">u'a'</span>, <span class="hljs-string">u'nine'</span>, <span class="hljs-string">u'to'</span>, <span class="hljs-string">u'is'</span>, ...<br /></code></pre>
<p>It returns all words in the vocabulary, sorted by decreasing frequency. We can get the word vector by:</p>
<pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_word_vector(<span class="hljs-string">"the"</span>)<br />array([<span class="hljs-number">-0.03087516</span>,  <span class="hljs-number">0.09221972</span>,  <span class="hljs-number">0.17660329</span>,  <span class="hljs-number">0.17308897</span>,  <span class="hljs-number">0.12863874</span>,<br />        <span class="hljs-number">0.13912526</span>, <span class="hljs-number">-0.09851588</span>,  <span class="hljs-number">0.00739991</span>,  <span class="hljs-number">0.37038437</span>, <span class="hljs-number">-0.00845221</span>,<br />        ...<br />       <span class="hljs-number">-0.21184735</span>, <span class="hljs-number">-0.05048715</span>, <span class="hljs-number">-0.34571868</span>,  <span class="hljs-number">0.23765688</span>,  <span class="hljs-number">0.23726143</span>],<br />      dtype=float32)<br /></code></pre>
<p>We can save this model on disk as a binary file:</p>
<pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.save_model(<span class="hljs-string">"result/fil9.bin"</span>)<br /></code></pre>
<p>and reload it later instead of training again:</p>
<pre><code class="hljs css language-py">$ python<br /><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fasttext<br /><span class="hljs-meta">&gt;&gt;&gt; </span>model = fasttext.load_model(<span class="hljs-string">"result/fil9.bin"</span>)<br /></code></pre>
</span></div></div></div></div>
<h2><a class="anchor" aria-hidden="true" id="advanced-readers-skipgram-versus-cbow"></a><a href="#advanced-readers-skipgram-versus-cbow" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced readers: skipgram versus cbow</h2>
<p>fastText provides two models for computing word representations: skipgram and cbow ('<strong>c</strong>ontinuous-<strong>b</strong>ag-<strong>o</strong>f-<strong>w</strong>ords').</p>
<p>The skipgram model learns to predict a target word thanks to a nearby word. On the other hand, the cbow model predicts the target word according to its context. The  context is represented as a bag of the  words contained in a fixed size window around the target word.</p>
<p>Let us illustrate this difference with an example:  given the sentence <em>'Poets have been mysteriously silent on the subject of cheese'</em> and the target word '<em>silent</em>', a skipgram model tries to predict the target using a random close-by word, like '<em>subject' <em>or</em> '</em>mysteriously<em>'</em><em>. <em>The cbow model takes all the words in a surrounding window, like {</em>been, <em>mysteriously</em>, on, the</em>}, and uses the sum of their vectors to predict the target. The figure below summarizes this difference with another example.</p>
<p><img src="https://fasttext.cc/img/cbo_vs_skipgram.png" alt="cbow vs skipgram">
To train a cbow model with fastText, you run the following command:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-73-tab-74" class="nav-link active" data-group="group_73" data-tab="tab-group-73-content-74">Command line</div><div id="tab-group-73-tab-75" class="nav-link" data-group="group_73" data-tab="tab-group-73-content-75">Python</div></div><div class="tab-content"><div id="tab-group-73-content-74" class="tab-pane active" data-group="group_73" tabindex="-1"><div><span><pre><code class="hljs css language-bash">./fasttext cbow -input data/fil9 -output result/fil9<br /></code></pre>
</span></div></div><div id="tab-group-73-content-75" class="tab-pane" data-group="group_73" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fasttext<br /><span class="hljs-meta">&gt;&gt;&gt; </span>model = fasttext.train_unsupervised(<span class="hljs-string">'data/fil9'</span>, <span class="hljs-string">"cbow"</span>)<br /></code></pre>
</span></div></div></div></div>
<p>In practice, we observe that skipgram models works better with subword information than cbow.</p>
<h2><a class="anchor" aria-hidden="true" id="advanced-readers-playing-with-the-parameters"></a><a href="#advanced-readers-playing-with-the-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced readers: playing with the parameters</h2>
<p>So far, we run fastText with the default parameters, but depending on the data, these parameters may not be optimal. Let us give an introduction to some of the key parameters for word vectors.</p>
<p>The most important parameters of the model are its dimension and the range of size for the subwords. The dimension (<em>dim</em>) controls the size of the vectors, the larger they are the more information they can capture but requires more data to be learned. But, if they are too large, they are harder and slower to train. By default, we use 100 dimensions, but any value in the 100-300 range is as popular. The subwords are all the substrings contained in a word between the minimum size (<em>minn</em>) and the maximal size (<em>maxn</em>). By default, we take all the subword between 3 and 6 characters, but other range could be more appropriate to different languages:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-76-tab-77" class="nav-link active" data-group="group_76" data-tab="tab-group-76-content-77">Command line</div><div id="tab-group-76-tab-78" class="nav-link" data-group="group_76" data-tab="tab-group-76-content-78">Python</div></div><div class="tab-content"><div id="tab-group-76-content-77" class="tab-pane active" data-group="group_76" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ ./fasttext skipgram -input data/fil9 -output result/fil9 -minn 2 -maxn 5 -dim 300<br /></code></pre>
</span></div></div><div id="tab-group-76-content-78" class="tab-pane" data-group="group_76" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fasttext<br /><span class="hljs-meta">&gt;&gt;&gt; </span>model = fasttext.train_unsupervised(<span class="hljs-string">'data/fil9'</span>, minn=<span class="hljs-number">2</span>, maxn=<span class="hljs-number">5</span>, dim=<span class="hljs-number">300</span>)<br /></code></pre>
</span></div></div></div></div>
<p>Depending on the quantity of data you have, you may want to change the parameters of the training.  The <em>epoch</em> parameter controls how many times the model will loop over your data. By default, we loop over the dataset 5 times.  If you dataset is extremely massive, you may want to loop over it less often. Another important parameter is the learning rate -<em>lr</em>. The higher the learning rate is, the faster the model converge to a solution but at the risk of overfitting to the dataset. The default value is 0.05 which is a good compromise. If you want to play with it we suggest to stay in the range of [0.01, 1]:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-79-tab-80" class="nav-link active" data-group="group_79" data-tab="tab-group-79-content-80">Command line</div><div id="tab-group-79-tab-81" class="nav-link" data-group="group_79" data-tab="tab-group-79-content-81">Python</div></div><div class="tab-content"><div id="tab-group-79-content-80" class="tab-pane active" data-group="group_79" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ ./fasttext skipgram -input data/fil9 -output result/fil9 -epoch 1 -lr 0.5<br /></code></pre>
</span></div></div><div id="tab-group-79-content-81" class="tab-pane" data-group="group_79" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fasttext<br /><span class="hljs-meta">&gt;&gt;&gt; </span>model = fasttext.train_unsupervised(<span class="hljs-string">'data/fil9'</span>, epoch=<span class="hljs-number">1</span>, lr=<span class="hljs-number">0.5</span>)<br /></code></pre>
</span></div></div></div></div>
<p>Finally , fastText is multi-threaded and uses 12 threads by default. If you have less CPU cores (say 4), you can easily set the number of threads using the <em>thread</em> flag:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-82-tab-83" class="nav-link active" data-group="group_82" data-tab="tab-group-82-content-83">Command line</div><div id="tab-group-82-tab-84" class="nav-link" data-group="group_82" data-tab="tab-group-82-content-84">Python</div></div><div class="tab-content"><div id="tab-group-82-content-83" class="tab-pane active" data-group="group_82" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ ./fasttext skipgram -input data/fil9 -output result/fil9 -thread 4<br /></code></pre>
</span></div></div><div id="tab-group-82-content-84" class="tab-pane" data-group="group_82" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> fasttext<br /><span class="hljs-meta">&gt;&gt;&gt; </span>model = fasttext.train_unsupervised(<span class="hljs-string">'data/fil9'</span>, thread=<span class="hljs-number">4</span>)<br /></code></pre>
</span></div></div></div></div>
<h2><a class="anchor" aria-hidden="true" id="printing-word-vectors"></a><a href="#printing-word-vectors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Printing word vectors</h2>
<p>Searching and printing word vectors directly from  the <code>fil9.vec</code>  file  is cumbersome. Fortunately, there is a <code>print-word-vectors</code> functionality in fastText.</p>
<p>For example, we can print the word vectors of words <em>asparagus,</em> <em>pidgey</em> and <em>yellow</em> with the following command:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-85-tab-86" class="nav-link active" data-group="group_85" data-tab="tab-group-85-content-86">Command line</div><div id="tab-group-85-tab-87" class="nav-link" data-group="group_85" data-tab="tab-group-85-content-87">Python</div></div><div class="tab-content"><div id="tab-group-85-content-86" class="tab-pane active" data-group="group_85" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"asparagus pidgey yellow"</span> | ./fasttext <span class="hljs-built_in">print</span>-word-vectors result/fil9.bin<br />asparagus 0.46826 -0.20187 -0.29122 -0.17918 0.31289 -0.31679 0.17828 -0.04418 ...<br />pidgey -0.16065 -0.45867 0.10565 0.036952 -0.11482 0.030053 0.12115 0.39725 ...<br />yellow -0.39965 -0.41068 0.067086 -0.034611 0.15246 -0.12208 -0.040719 -0.30155 ...<br /></code></pre>
</span></div></div><div id="tab-group-85-content-87" class="tab-pane" data-group="group_85" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>[model.get_word_vector(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-string">"asparagus"</span>, <span class="hljs-string">"pidgey"</span>, <span class="hljs-string">"yellow"</span>]]<br />[array([<span class="hljs-number">-0.25751096</span>, <span class="hljs-number">-0.18716481</span>,  <span class="hljs-number">0.06921121</span>,  <span class="hljs-number">0.06455903</span>,  <span class="hljs-number">0.29168844</span>,<br />        <span class="hljs-number">0.15426874</span>, <span class="hljs-number">-0.33448914</span>, <span class="hljs-number">-0.427215</span>  ,  <span class="hljs-number">0.7813013</span> , <span class="hljs-number">-0.10600132</span>,<br />        ...<br />        <span class="hljs-number">0.37090245</span>,  <span class="hljs-number">0.39266172</span>, <span class="hljs-number">-0.4555302</span> ,  <span class="hljs-number">0.27452755</span>,  <span class="hljs-number">0.00467369</span>],<br />      dtype=float32),<br /> array([<span class="hljs-number">-0.20613593</span>, <span class="hljs-number">-0.25325796</span>, <span class="hljs-number">-0.2422259</span> , <span class="hljs-number">-0.21067499</span>,  <span class="hljs-number">0.32879013</span>,<br />        <span class="hljs-number">0.7269511</span> ,  <span class="hljs-number">0.3782259</span> ,  <span class="hljs-number">0.11274897</span>,  <span class="hljs-number">0.246764</span>  , <span class="hljs-number">-0.6423613</span> ,<br />        ...<br />        <span class="hljs-number">0.46302193</span>,  <span class="hljs-number">0.2530962</span> , <span class="hljs-number">-0.35795924</span>,  <span class="hljs-number">0.5755718</span> ,  <span class="hljs-number">0.09843876</span>],<br />      dtype=float32),<br /> array([<span class="hljs-number">-0.304823</span>  ,  <span class="hljs-number">0.2543754</span> , <span class="hljs-number">-0.2198013</span> , <span class="hljs-number">-0.25421786</span>,  <span class="hljs-number">0.11219151</span>,<br />        <span class="hljs-number">0.38286993</span>, <span class="hljs-number">-0.22636674</span>, <span class="hljs-number">-0.54023844</span>,  <span class="hljs-number">0.41095474</span>, <span class="hljs-number">-0.3505803</span> ,<br />        ...<br />        <span class="hljs-number">0.54788435</span>,  <span class="hljs-number">0.36740595</span>, <span class="hljs-number">-0.5678512</span> ,  <span class="hljs-number">0.07523401</span>, <span class="hljs-number">-0.08701935</span>],<br />      dtype=float32)]<br /><br /></code></pre>
</span></div></div></div></div>
<p>A nice feature is that you can also query for words that did not appear in your data! Indeed words are represented by the sum of its substrings. As long as the unknown word is made of known substrings, there is a representation of it!</p>
<p>As an example let's try with a misspelled word:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-88-tab-89" class="nav-link active" data-group="group_88" data-tab="tab-group-88-content-89">Command line</div><div id="tab-group-88-tab-90" class="nav-link" data-group="group_88" data-tab="tab-group-88-content-90">Python</div></div><div class="tab-content"><div id="tab-group-88-content-89" class="tab-pane active" data-group="group_88" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">"enviroment"</span> | ./fasttext <span class="hljs-built_in">print</span>-word-vectors result/fil9.bin<br /></code></pre>
</span></div></div><div id="tab-group-88-content-90" class="tab-pane" data-group="group_88" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_word_vector(<span class="hljs-string">"enviroment"</span>)<br /></code></pre>
</span></div></div></div></div>
<p>You still get a word vector for it! But how good it is? Let's find out in the next sections!</p>
<h2><a class="anchor" aria-hidden="true" id="nearest-neighbor-queries"></a><a href="#nearest-neighbor-queries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Nearest neighbor queries</h2>
<p>A simple way to check the quality of a word vector is to look at its nearest neighbors. This give an intuition of the type of semantic information the vectors are able to capture.</p>
<p>This can be achieved with the nearest neighbor (<em>nn</em>) functionality. For example, we can query the 10 nearest neighbors of a word by running the following command:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-91-tab-92" class="nav-link active" data-group="group_91" data-tab="tab-group-91-content-92">Command line</div><div id="tab-group-91-tab-93" class="nav-link" data-group="group_91" data-tab="tab-group-91-content-93">Python</div></div><div class="tab-content"><div id="tab-group-91-content-92" class="tab-pane active" data-group="group_91" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ ./fasttext nn result/fil9.bin<br />Pre-computing word vectors... <span class="hljs-keyword">done</span>.<br /></code></pre>
<p>Then we are prompted to type our query word, let us try <em>asparagus</em> :</p>
<pre><code class="hljs css language-bash">Query word? asparagus<br />beetroot 0.812384<br />tomato 0.806688<br />horseradish 0.805928<br />spinach 0.801483<br />licorice 0.791697<br />lingonberries 0.781507<br />asparagales 0.780756<br />lingonberry 0.778534<br />celery 0.774529<br />beets 0.773984<br /></code></pre>
</span></div></div><div id="tab-group-91-content-93" class="tab-pane" data-group="group_91" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_nearest_neighbors(<span class="hljs-string">'asparagus'</span>)<br />[(<span class="hljs-number">0.812384</span>, <span class="hljs-string">u'beetroot'</span>), (<span class="hljs-number">0.806688</span>, <span class="hljs-string">u'tomato'</span>), (<span class="hljs-number">0.805928</span>, <span class="hljs-string">u'horseradish'</span>), (<span class="hljs-number">0.801483</span>, <span class="hljs-string">u'spinach'</span>), (<span class="hljs-number">0.791697</span>, <span class="hljs-string">u'licorice'</span>), (<span class="hljs-number">0.781507</span>, <span class="hljs-string">u'lingonberries'</span>), (<span class="hljs-number">0.780756</span>, <span class="hljs-string">u'asparagales'</span>), (<span class="hljs-number">0.778534</span>, <span class="hljs-string">u'lingonberry'</span>), (<span class="hljs-number">0.774529</span>, <span class="hljs-string">u'celery'</span>), (<span class="hljs-number">0.773984</span>, <span class="hljs-string">u'beets'</span>)]<br /></code></pre>
</span></div></div></div></div>
<p>Nice! It seems that vegetable vectors are similar. Note that the nearest neighbor is the word <em>asparagus</em> itself, this means that this word appeared in the dataset. What about pokemons?</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-94-tab-95" class="nav-link active" data-group="group_94" data-tab="tab-group-94-content-95">Command line</div><div id="tab-group-94-tab-96" class="nav-link" data-group="group_94" data-tab="tab-group-94-content-96">Python</div></div><div class="tab-content"><div id="tab-group-94-content-95" class="tab-pane active" data-group="group_94" tabindex="-1"><div><span><pre><code class="hljs css language-bash">Query word? pidgey<br />pidgeot 0.891801<br />pidgeotto 0.885109<br />pidge 0.884739<br />pidgeon 0.787351<br />pok 0.781068<br />pikachu 0.758688<br />charizard 0.749403<br />squirtle 0.742582<br />beedrill 0.741579<br />charmeleon 0.733625<br /></code></pre>
</span></div></div><div id="tab-group-94-content-96" class="tab-pane" data-group="group_94" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_nearest_neighbors(<span class="hljs-string">'pidgey'</span>)<br />[(<span class="hljs-number">0.891801</span>, <span class="hljs-string">u'pidgeot'</span>), (<span class="hljs-number">0.885109</span>, <span class="hljs-string">u'pidgeotto'</span>), (<span class="hljs-number">0.884739</span>, <span class="hljs-string">u'pidge'</span>), (<span class="hljs-number">0.787351</span>, <span class="hljs-string">u'pidgeon'</span>), (<span class="hljs-number">0.781068</span>, <span class="hljs-string">u'pok'</span>), (<span class="hljs-number">0.758688</span>, <span class="hljs-string">u'pikachu'</span>), (<span class="hljs-number">0.749403</span>, <span class="hljs-string">u'charizard'</span>), (<span class="hljs-number">0.742582</span>, <span class="hljs-string">u'squirtle'</span>), (<span class="hljs-number">0.741579</span>, <span class="hljs-string">u'beedrill'</span>), (<span class="hljs-number">0.733625</span>, <span class="hljs-string">u'charmeleon'</span>)]<br /></code></pre>
</span></div></div></div></div>
<p>Different evolution of the same Pokemon have close-by vectors! But what about our misspelled word, is its vector close to anything reasonable? Let s find out:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-97-tab-98" class="nav-link active" data-group="group_97" data-tab="tab-group-97-content-98">Command line</div><div id="tab-group-97-tab-99" class="nav-link" data-group="group_97" data-tab="tab-group-97-content-99">Python</div></div><div class="tab-content"><div id="tab-group-97-content-98" class="tab-pane active" data-group="group_97" tabindex="-1"><div><span><pre><code class="hljs css language-bash">Query word? enviroment<br />enviromental 0.907951<br />environ 0.87146<br />enviro 0.855381<br />environs 0.803349<br />environnement 0.772682<br />enviromission 0.761168<br />realclimate 0.716746<br />environment 0.702706<br />acclimatation 0.697196<br />ecotourism 0.697081<br /></code></pre>
</span></div></div><div id="tab-group-97-content-99" class="tab-pane" data-group="group_97" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_nearest_neighbors(<span class="hljs-string">'enviroment'</span>)<br />[(<span class="hljs-number">0.907951</span>, <span class="hljs-string">u'enviromental'</span>), (<span class="hljs-number">0.87146</span>, <span class="hljs-string">u'environ'</span>), (<span class="hljs-number">0.855381</span>, <span class="hljs-string">u'enviro'</span>), (<span class="hljs-number">0.803349</span>, <span class="hljs-string">u'environs'</span>), (<span class="hljs-number">0.772682</span>, <span class="hljs-string">u'environnement'</span>), (<span class="hljs-number">0.761168</span>, <span class="hljs-string">u'enviromission'</span>), (<span class="hljs-number">0.716746</span>, <span class="hljs-string">u'realclimate'</span>), (<span class="hljs-number">0.702706</span>, <span class="hljs-string">u'environment'</span>), (<span class="hljs-number">0.697196</span>, <span class="hljs-string">u'acclimatation'</span>), (<span class="hljs-number">0.697081</span>, <span class="hljs-string">u'ecotourism'</span>)]<br /></code></pre>
</span></div></div></div></div>
<p>Thanks to the information contained within the word, the vector of our misspelled word matches to reasonable words! It is not perfect but the main information has been captured.</p>
<h2><a class="anchor" aria-hidden="true" id="advanced-reader-measure-of-similarity"></a><a href="#advanced-reader-measure-of-similarity" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Advanced reader: measure of similarity</h2>
<p>In order to find nearest neighbors, we need to compute a similarity score between words. Our words are represented by continuous word vectors and we can thus apply simple similarities to them. In particular we use the cosine of the angles between two vectors. This similarity is computed for all words in the vocabulary, and the 10 most similar words are shown.  Of course, if the word appears in the vocabulary, it will appear on top, with a similarity of 1.</p>
<h2><a class="anchor" aria-hidden="true" id="word-analogies"></a><a href="#word-analogies" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Word analogies</h2>
<p>In a similar spirit, one can play around with word analogies. For example, we can see if our model can guess what is to France, and what Berlin is to Germany.</p>
<p>This can be done with the <em>analogies</em> functionality. It takes a word triplet (like <em>Germany Berlin France</em>) and outputs  the analogy:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-100-tab-101" class="nav-link active" data-group="group_100" data-tab="tab-group-100-content-101">Command line</div><div id="tab-group-100-tab-102" class="nav-link" data-group="group_100" data-tab="tab-group-100-content-102">Python</div></div><div class="tab-content"><div id="tab-group-100-content-101" class="tab-pane active" data-group="group_100" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ ./fasttext analogies result/fil9.bin<br />Pre-computing word vectors... <span class="hljs-keyword">done</span>.<br />Query triplet (A - B + C)? berlin germany france<br />paris 0.896462<br />bourges 0.768954<br />louveciennes 0.765569<br />toulouse 0.761916<br />valenciennes 0.760251<br />montpellier 0.752747<br />strasbourg 0.744487<br />meudon 0.74143<br />bordeaux 0.740635<br />pigneaux 0.736122<br /></code></pre>
</span></div></div><div id="tab-group-100-content-102" class="tab-pane" data-group="group_100" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_analogies(<span class="hljs-string">"berlin"</span>, <span class="hljs-string">"germany"</span>, <span class="hljs-string">"france"</span>)<br />[(<span class="hljs-number">0.896462</span>, <span class="hljs-string">u'paris'</span>), (<span class="hljs-number">0.768954</span>, <span class="hljs-string">u'bourges'</span>), (<span class="hljs-number">0.765569</span>, <span class="hljs-string">u'louveciennes'</span>), (<span class="hljs-number">0.761916</span>, <span class="hljs-string">u'toulouse'</span>), (<span class="hljs-number">0.760251</span>, <span class="hljs-string">u'valenciennes'</span>), (<span class="hljs-number">0.752747</span>, <span class="hljs-string">u'montpellier'</span>), (<span class="hljs-number">0.744487</span>, <span class="hljs-string">u'strasbourg'</span>), (<span class="hljs-number">0.74143</span>, <span class="hljs-string">u'meudon'</span>), (<span class="hljs-number">0.740635</span>, <span class="hljs-string">u'bordeaux'</span>), (<span class="hljs-number">0.736122</span>, <span class="hljs-string">u'pigneaux'</span>)]<br /></code></pre>
</span></div></div></div></div>
<p>The answer provided by our model is <em>Paris</em>, which is correct. Let's have a look at a less obvious example:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-103-tab-104" class="nav-link active" data-group="group_103" data-tab="tab-group-103-content-104">Command line</div><div id="tab-group-103-tab-105" class="nav-link" data-group="group_103" data-tab="tab-group-103-content-105">Python</div></div><div class="tab-content"><div id="tab-group-103-content-104" class="tab-pane active" data-group="group_103" tabindex="-1"><div><span><pre><code class="hljs css language-bash">Query triplet (A - B + C)? psx sony nintendo<br />gamecube 0.803352<br />nintendogs 0.792646<br />playstation 0.77344<br />sega 0.772165<br />gameboy 0.767959<br />arcade 0.754774<br />playstationjapan 0.753473<br />gba 0.752909<br />dreamcast 0.74907<br />famicom 0.745298<br /></code></pre>
</span></div></div><div id="tab-group-103-content-105" class="tab-pane" data-group="group_103" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_analogies(<span class="hljs-string">"psx"</span>, <span class="hljs-string">"sony"</span>, <span class="hljs-string">"nintendo"</span>)<br />[(<span class="hljs-number">0.803352</span>, <span class="hljs-string">u'gamecube'</span>), (<span class="hljs-number">0.792646</span>, <span class="hljs-string">u'nintendogs'</span>), (<span class="hljs-number">0.77344</span>, <span class="hljs-string">u'playstation'</span>), (<span class="hljs-number">0.772165</span>, <span class="hljs-string">u'sega'</span>), (<span class="hljs-number">0.767959</span>, <span class="hljs-string">u'gameboy'</span>), (<span class="hljs-number">0.754774</span>, <span class="hljs-string">u'arcade'</span>), (<span class="hljs-number">0.753473</span>, <span class="hljs-string">u'playstationjapan'</span>), (<span class="hljs-number">0.752909</span>, <span class="hljs-string">u'gba'</span>), (<span class="hljs-number">0.74907</span>, <span class="hljs-string">u'dreamcast'</span>), (<span class="hljs-number">0.745298</span>, <span class="hljs-string">u'famicom'</span>)]<br /></code></pre>
</span></div></div></div></div>
<p>Our model considers that the <em>nintendo</em> analogy of a <em>psx</em> is the <em>gamecube</em>, which seems  reasonable. Of course the quality of the analogies depend on the dataset used to train the model and one can only hope to cover fields only in the dataset.</p>
<h2><a class="anchor" aria-hidden="true" id="importance-of-character-n-grams"></a><a href="#importance-of-character-n-grams" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Importance of character n-grams</h2>
<p>Using subword-level information is particularly interesting to build vectors for unknown words. For example, the word <em>gearshift</em> does not exist on Wikipedia but we can still query its closest existing words:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-106-tab-107" class="nav-link active" data-group="group_106" data-tab="tab-group-106-content-107">Command line</div><div id="tab-group-106-tab-108" class="nav-link" data-group="group_106" data-tab="tab-group-106-content-108">Python</div></div><div class="tab-content"><div id="tab-group-106-content-107" class="tab-pane active" data-group="group_106" tabindex="-1"><div><span><pre><code class="hljs css language-bash">Query word? gearshift<br />gearing 0.790762<br />flywheels 0.779804<br />flywheel 0.777859<br />gears 0.776133<br />driveshafts 0.756345<br />driveshaft 0.755679<br />daisywheel 0.749998<br />wheelsets 0.748578<br />epicycles 0.744268<br />gearboxes 0.73986<br /></code></pre>
</span></div></div><div id="tab-group-106-content-108" class="tab-pane" data-group="group_106" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_nearest_neighbors(<span class="hljs-string">'gearshift'</span>)<br />[(<span class="hljs-number">0.790762</span>, <span class="hljs-string">u'gearing'</span>), (<span class="hljs-number">0.779804</span>, <span class="hljs-string">u'flywheels'</span>), (<span class="hljs-number">0.777859</span>, <span class="hljs-string">u'flywheel'</span>), (<span class="hljs-number">0.776133</span>, <span class="hljs-string">u'gears'</span>), (<span class="hljs-number">0.756345</span>, <span class="hljs-string">u'driveshafts'</span>), (<span class="hljs-number">0.755679</span>, <span class="hljs-string">u'driveshaft'</span>), (<span class="hljs-number">0.749998</span>, <span class="hljs-string">u'daisywheel'</span>), (<span class="hljs-number">0.748578</span>, <span class="hljs-string">u'wheelsets'</span>), (<span class="hljs-number">0.744268</span>, <span class="hljs-string">u'epicycles'</span>), (<span class="hljs-number">0.73986</span>, <span class="hljs-string">u'gearboxes'</span>)]<br /></code></pre>
</span></div></div></div></div>
<p>Most of the retrieved words share substantial substrings but a few are actually quite different, like <em>cogwheel</em>. You can try other words like <em>sunbathe</em> or <em>grandnieces</em>.</p>
<p>Now that we have seen the interest of subword information for unknown words, let's check how it compares to a model that does not use subword information. To train a model without subwords, just run the following command:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-109-tab-110" class="nav-link active" data-group="group_109" data-tab="tab-group-109-content-110">Command line</div><div id="tab-group-109-tab-111" class="nav-link" data-group="group_109" data-tab="tab-group-109-content-111">Python</div></div><div class="tab-content"><div id="tab-group-109-content-110" class="tab-pane active" data-group="group_109" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ ./fasttext skipgram -input data/fil9 -output result/fil9-none -maxn 0<br /></code></pre>
<p>The results are saved in result/fil9-non.vec and result/fil9-non.bin.</p>
</span></div></div><div id="tab-group-109-content-111" class="tab-pane" data-group="group_109" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model_without_subwords = fasttext.train_unsupervised(<span class="hljs-string">'data/fil9'</span>, maxn=<span class="hljs-number">0</span>)<br /></code></pre>
</span></div></div></div></div>
<p>To illustrate the difference, let us take an uncommon word in Wikipedia, like <em>accomodation</em> which is a misspelling of <em>accommodation</em><em>.</em> Here is the nearest neighbors obtained without subwords:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-112-tab-113" class="nav-link active" data-group="group_112" data-tab="tab-group-112-content-113">Command line</div><div id="tab-group-112-tab-114" class="nav-link" data-group="group_112" data-tab="tab-group-112-content-114">Python</div></div><div class="tab-content"><div id="tab-group-112-content-113" class="tab-pane active" data-group="group_112" tabindex="-1"><div><span><pre><code class="hljs css language-bash">$ ./fasttext nn result/fil9-none.bin<br />Query word? accomodation<br />sunnhordland 0.775057<br />accomodations 0.769206<br />administrational 0.753011<br />laponian 0.752274<br />ammenities 0.750805<br />dachas 0.75026<br />vuosaari 0.74172<br />hostelling 0.739995<br />greenbelts 0.733975<br />asserbo 0.732465<br /></code></pre>
</span></div></div><div id="tab-group-112-content-114" class="tab-pane" data-group="group_112" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model_without_subwords.get_nearest_neighbors(<span class="hljs-string">'accomodation'</span>)<br />[(<span class="hljs-number">0.775057</span>, <span class="hljs-string">u'sunnhordland'</span>), (<span class="hljs-number">0.769206</span>, <span class="hljs-string">u'accomodations'</span>), (<span class="hljs-number">0.753011</span>, <span class="hljs-string">u'administrational'</span>), (<span class="hljs-number">0.752274</span>, <span class="hljs-string">u'laponian'</span>), (<span class="hljs-number">0.750805</span>, <span class="hljs-string">u'ammenities'</span>), (<span class="hljs-number">0.75026</span>, <span class="hljs-string">u'dachas'</span>), (<span class="hljs-number">0.74172</span>, <span class="hljs-string">u'vuosaari'</span>), (<span class="hljs-number">0.739995</span>, <span class="hljs-string">u'hostelling'</span>), (<span class="hljs-number">0.733975</span>, <span class="hljs-string">u'greenbelts'</span>), (<span class="hljs-number">0.732465</span>, <span class="hljs-string">u'asserbo'</span>)]<br /></code></pre>
</span></div></div></div></div>
<p>The result does not make much sense, most of these words are unrelated. On the other hand, using subword information gives the following list of nearest neighbors:</p>
<div class="tabs"><div class="nav-tabs"><div id="tab-group-115-tab-116" class="nav-link active" data-group="group_115" data-tab="tab-group-115-content-116">Command line</div><div id="tab-group-115-tab-117" class="nav-link" data-group="group_115" data-tab="tab-group-115-content-117">Python</div></div><div class="tab-content"><div id="tab-group-115-content-116" class="tab-pane active" data-group="group_115" tabindex="-1"><div><span><pre><code class="hljs css language-bash">Query word? accomodation<br />accomodations 0.96342<br />accommodation 0.942124<br />accommodations 0.915427<br />accommodative 0.847751<br />accommodating 0.794353<br />accomodated 0.740381<br />amenities 0.729746<br />catering 0.725975<br />accomodate 0.703177<br />hospitality 0.701426<br /></code></pre>
</span></div></div><div id="tab-group-115-content-117" class="tab-pane" data-group="group_115" tabindex="-1"><div><span><pre><code class="hljs css language-py"><span class="hljs-meta">&gt;&gt;&gt; </span>model.get_nearest_neighbors(<span class="hljs-string">'accomodation'</span>)<br />[(<span class="hljs-number">0.96342</span>, <span class="hljs-string">u'accomodations'</span>), (<span class="hljs-number">0.942124</span>, <span class="hljs-string">u'accommodation'</span>), (<span class="hljs-number">0.915427</span>, <span class="hljs-string">u'accommodations'</span>), (<span class="hljs-number">0.847751</span>, <span class="hljs-string">u'accommodative'</span>), (<span class="hljs-number">0.794353</span>, <span class="hljs-string">u'accommodating'</span>), (<span class="hljs-number">0.740381</span>, <span class="hljs-string">u'accomodated'</span>), (<span class="hljs-number">0.729746</span>, <span class="hljs-string">u'amenities'</span>), (<span class="hljs-number">0.725975</span>, <span class="hljs-string">u'catering'</span>), (<span class="hljs-number">0.703177</span>, <span class="hljs-string">u'accomodate'</span>), (<span class="hljs-number">0.701426</span>, <span class="hljs-string">u'hospitality'</span>)]<br /></code></pre>
</span></div></div></div></div>
<p>The nearest neighbors capture different variation around the word <em>accommodation</em>. We also get semantically related words such as <em>amenities</em> or <em>catering</em>.</p>
<h2><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h2>
<p>In this tutorial, we show how to obtain word vectors from Wikipedia. This can be done for any language and we provide <a href="https://fasttext.cc/docs/en/pretrained-vectors.html">pre-trained models</a> with the default setting for 294 of them.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/en/supervised-tutorial.html"><span class="arrow-prev">← </span><span>Text classification</span></a><a class="docs-next button" href="/docs/en/autotune.html"><span>Automatic hyperparameter optimization</span><span class="arrow-next"> →</span></a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/fasttext-icon-white-web.png" alt="fastText"/></a><div><h5>Support</h5><a href="/docs/en/support.html">Getting Started</a><a href="/docs/en/supervised-tutorial.html">Tutorials</a><a href="/docs/en/faqs.html">FAQs</a><a href="/docs/en/api.html">API</a></div><div><h5>Community</h5><a href="https://www.facebook.com/groups/1174547215919768/" target="_blank">Facebook Group</a><a href="http://stackoverflow.com/questions/tagged/fasttext" target="_blank">Stack Overflow</a><a href="https://groups.google.com/forum/#!forum/fasttext-library" target="_blank">Google Group</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/facebookresearch/fastText" target="_blank">GitHub</a><a class="github-button" href="https://github.com/facebookresearch/fastText/" data-icon="octicon-star" data-count-href="/fastText/stargazers" data-count-api="/repos/fastText#stargazers_count" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://code.facebook.com/projects/" target="_blank" class="fbOpenSource"><img src="/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2020 Facebook Inc.</section></footer></div></body></html>